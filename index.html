<html>
  <head>
    <style>
      * {
        font-family: Helvetica;
      }

      nav {
        display: flex;
        justify-content: space-around;
        padding: 1rem;
        text-transform: uppercase;
      }

      a {
        padding: 1rem;
      }

      a.selected {
        background-color: slategray;
        border-radius: 10%;
        color: white;
      }

      form {
        display: flex;
        border: 1px solid black;
        flex-direction: column;
        justify-content: space-between;
      }

      input {
        font-size: larger;
        margin: 0.5rem;
      }

      button {
        font-size: larger;
        margin: 0.5rem;
      }

      ul > li {
        display: flex;
        justify-content: space-around;
        list-style-type: none;
      }

      li > a {
        font-weight: bold;
        width: 50%;
        text-align: center;
      }

      li > button {
        width: 50%;
      }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/axios/0.18.0/axios.js"></script>
    <script src="https://unpkg.com/babel-standalone@6/babel.min.js"></script>
    <script
      src="https://unpkg.com/react@16/umd/react.development.js"
      crossorigin
    ></script>
    <script
      src="https://unpkg.com/react-dom@16/umd/react-dom.development.js"
      crossorigin
    ></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react-router-dom/5.0.0/react-router-dom.js"></script>
  </head>
  <body>
    <div id="root"></div>
    <script type="text/babel">
      //Destructuring
      const { Component } = React
      const { HashRouter, Link, Route, Switch, Redirect } = ReactRouterDOM
      const API = "https://acme-users-api-rev.herokuapp.com/api"

      //Fetches User Data
      const fetchUser = async () => {
        const storage = window.localStorage
        const userId = storage.getItem("userId")
        if (userId) {
          try {
            return (await axios.get(`${API}/users/detail/${userId}`)).data
          } catch (ex) {
            storage.removeItem("userId")
            return fetchUser()
          }
        }
        const user = (await axios.get(`${API}/users/random`)).data
        storage.setItem("userId", user.id)
        return user
      }

      // be careful with this function
      // Fetches Bookmark Data
      const fetchBookmarks = async userId => {
        try {
          return (await axios.get(`${API}/users/${userId}/bookmarks`)).data
        } catch (ex) {
          // if it fails because server down, it'll keep hitting it
          // over and over...
          return fetchBookmarks()
        }
      }

      // Bookmark Component
      const Bookmarks = ({ bookmarks, destroy, match }) => {
        // I like the way of doing this, pretty clean I think!
        const filter = match.params.filter
        let filtered = bookmarks.filter(
          bookmark => bookmark.category === filter
        )
        return (
          <ul>
            {filtered.map((bookmark, index) => (
              <li key={bookmark.id}>
                <a href={bookmark.url}> {bookmark.url} </a>
                <button onClick={() => destroy(bookmark)}> Destroy </button>
              </li>
            ))}
          </ul>
        )
      }

      // NavBar Component
      const NavBar = ({ bookmarks, path, categories }) => {
        return (
          <nav>
            {categories.map((category, idx) => {
              const matches = bookmarks.filter(
                bookmark => bookmark.category === category
              )
              return (
                <Link
                  key={idx}
                  to={category}
                  className={path === `/${category}` ? "selected" : ""}
                >
                  {category} ({matches.length})
                </Link>
              )
            })}
          </nav>
        )
      }

      // Creates Form
      class Form extends Component {
        constructor() {
          super()
          this.state = {
            url: "",
            category: "",
          }
          this.create = this.create.bind(this)
        }

        create() {
          const { category, url } = this.state
          // you double dipped on the history here
          // const { history } = this.props
          // may have worked here
          const { history } = this.props.history
          this.props
            .create({ category, url })
            .then(() => history.push(`/${category}`))
        }

        render() {
          const { url, category } = this.state
          return (
            // good on submit!
            // just remember to do event.preventDefault!!
            // also, why does this get history?
            <form onSubmit={this.create} history={history}>
              <input
                type="text"
                value={url}
                onChange={ev => this.setState({ url: ev.target.value })}
                placeholder="url"
              />
              <input
                type="text"
                value={category}
                onChange={ev => this.setState({ category: ev.target.value })}
                placeholder="category"
              />
              <button disabled={!url || !category ? "disabled" : ""}>
                {" "}
                Create{" "}
              </button>
            </form>
          )
        }
      }

      // Creates App
      class App extends Component {
        constructor() {
          super()
          this.state = {
            user: {},
            bookmarks: [],
            categories: [],
          }
          this.create = this.create.bind(this)
          this.destroy = this.destroy.bind(this)
        }

        async componentDidMount() {
          const user = await fetchUser()
          const bookmarks = await fetchBookmarks(user.id)
          // so notice how you DERIVE categories from bookmarks?
          // this generally means it shouldn't be in the state
          // and should be generated in the render function
          // making it derived means less bugs later
          const categories = this.state.categories
          bookmarks.filter(bookmark => {
            if (!categories.includes(bookmark.category)) {
              categories.push(bookmark.category)
            }
          })
          this.setState({ user, bookmarks, categories })
        }

        async create(bookmark) {
          // because here now, you'll need to update your categories
          // (and because you forgot, you get bad ui)
          const bookmarkData = (
            await axios.post(
              `${API}/users/${this.state.user.id}/bookmarks/`,
              bookmark
            )
          ).data
          const bookmarks = [...this.state.bookmarks, bookmarkData]
          this.setState({ bookmarks })
        }

        async destroy(bookmark) {
          await axios.delete(
            `${API}/users/${bookmark.userId}/bookmarks/${bookmark.id}`
          )
          this.setState({
            bookmarks: this.state.bookmarks.filter(
              item => item.id !== bookmark.id
            ),
          })
          // similar here too!
        }

        render() {
          // but if you defined the categories here and derived them here
          // they would just generate everytime your state changes!
          // which means you get dynamic categories for free
          const { user, bookmarks, categories } = this.state
          const { create, destroy } = this
          // while this works (putting everything under one route) FOR THIS CASE
          // please don't do this normally
          // use differernt routes for everything
          return (
            <HashRouter>
              <h1>{`${user.fullName} (${bookmarks.length}) Bookmark(s)`}</h1>
              <Route
                path="/:filter?"
                render={props => (
                  <main>
                    <NavBar
                      path={props.location.pathname}
                      bookmarks={bookmarks}
                      categories={categories}
                    />
                    <Form history={props.history} create={create} user={user} />
                    <Bookmarks
                      {...props}
                      destroy={destroy}
                      bookmarks={bookmarks}
                    />
                  </main>
                )}
              />
            </HashRouter>
          )
        }
      }

      // Renders Data into Webpage
      const root = document.querySelector("#root")
      ReactDOM.render(<App />, root)
    </script>
  </body>
</html>
